{"id":"node_modules/@tensorflow/tfjs-core/dist/backends/backend.js","dependencies":[{"name":"/Users/gregwilken/code/chadnotchad/train/node_modules/@tensorflow/tfjs-core/dist/backends/backend.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/gregwilken/code/chadnotchad/train/node_modules/@tensorflow/tfjs-core/src/backends/backend.ts","includedInParent":true,"mtime":499162500000},{"name":"/Users/gregwilken/code/chadnotchad/train/package.json","includedInParent":true,"mtime":1568570823773},{"name":"/Users/gregwilken/code/chadnotchad/.babelrc","includedInParent":true,"mtime":1568502470146},{"name":"/Users/gregwilken/code/chadnotchad/train/node_modules/@tensorflow/tfjs-core/package.json","includedInParent":true,"mtime":1568570765035}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EPSILON_FLOAT32 = 1e-7;\nexports.EPSILON_FLOAT16 = 1e-4;\n/** Convenient class for storing tensor-related data. */\nvar DataStorage = /** @class */ (function () {\n    function DataStorage(backend, dataMover) {\n        this.backend = backend;\n        this.dataMover = dataMover;\n        this.data = new WeakMap();\n    }\n    DataStorage.prototype.get = function (dataId) {\n        if (!this.data.has(dataId)) {\n            this.dataMover.moveData(this.backend, dataId);\n        }\n        return this.data.get(dataId);\n    };\n    DataStorage.prototype.set = function (dataId, value) {\n        this.data.set(dataId, value);\n    };\n    DataStorage.prototype.has = function (dataId) {\n        return this.data.has(dataId);\n    };\n    DataStorage.prototype.delete = function (dataId) {\n        return this.data.delete(dataId);\n    };\n    return DataStorage;\n}());\nexports.DataStorage = DataStorage;\n/**\n * The interface that defines the kernels that should be implemented when\n * adding a new backend. New backends don't need to implement every one of the\n * methods, this can be done gradually (throw an error for unimplemented\n * methods).\n */\nvar KernelBackend = /** @class */ (function () {\n    function KernelBackend() {\n    }\n    KernelBackend.prototype.time = function (f) {\n        throw new Error('Not yet implemented.');\n    };\n    KernelBackend.prototype.read = function (dataId) {\n        throw new Error('Not yet implemented.');\n    };\n    KernelBackend.prototype.readSync = function (dataId) {\n        throw new Error('Not yet implemented.');\n    };\n    KernelBackend.prototype.disposeData = function (dataId) {\n        throw new Error('Not yet implemented.');\n    };\n    KernelBackend.prototype.write = function (dataId, values) {\n        throw new Error('Not yet implemented.');\n    };\n    KernelBackend.prototype.fromPixels = function (pixels, numChannels) {\n        throw new Error('Not yet implemented.');\n    };\n    KernelBackend.prototype.register = function (dataId, shape, dtype) {\n        throw new Error('Not yet implemented.');\n    };\n    KernelBackend.prototype.memory = function () {\n        throw new Error('Not yet implemented.');\n    };\n    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */\n    KernelBackend.prototype.floatPrecision = function () {\n        throw new Error('Not yet implemented');\n    };\n    /** Returns the smallest representable number.  */\n    KernelBackend.prototype.epsilon = function () {\n        return this.floatPrecision() === 32 ? exports.EPSILON_FLOAT32 : exports.EPSILON_FLOAT16;\n    };\n    KernelBackend.prototype.batchMatMul = function (a, b, transposeA, transposeB) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.fusedBatchMatMul = function (_a) {\n        var a = _a.a, b = _a.b, transposeA = _a.transposeA, transposeB = _a.transposeB, bias = _a.bias, activation = _a.activation, preluActivationWeights = _a.preluActivationWeights;\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.slice = function (x, begin, size) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.stridedSlice = function (x, begin, end, strides) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.unstack = function (x, axis) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.reverse = function (a, axis) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.concat = function (tensors, axis) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.neg = function (a) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.add = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.addN = function (tensors) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.subtract = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.multiply = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.realDivide = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.floorDiv = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.sum = function (x, axes) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.prod = function (x, axes) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.unsortedSegmentSum = function (x, segmentIds, numSegments) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.argMin = function (x, axis) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.argMax = function (x, axis) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.equal = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.notEqual = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.less = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.lessEqual = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.greater = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.greaterEqual = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.logicalNot = function (a) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.logicalAnd = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.logicalOr = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.where = function (condition) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.select = function (condition, a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.topk = function (x, k, sorted) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.min = function (x, axes) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.minimum = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.mod = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.max = function (x, axes) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.maximum = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.all = function (x, axes) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.any = function (x, axes) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.squaredDifference = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.ceil = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.floor = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.round = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.sign = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.isNaN = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.isInf = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.isFinite = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.pow = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.exp = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.expm1 = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.log = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.log1p = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.sqrt = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.rsqrt = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.square = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.reciprocal = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.relu = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.prelu = function (x, a) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.elu = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.eluDer = function (dy, y) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.selu = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.int = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.clip = function (x, min, max) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.abs = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.complexAbs = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.sigmoid = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.softplus = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.sin = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.cos = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.tan = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.asin = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.acos = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.atan = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.atan2 = function (a, b) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.sinh = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.cosh = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.tanh = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.asinh = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.acosh = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.atanh = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.erf = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.step = function (x, alpha) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.fusedConv2d = function (x, filter, convInfo, bias, activation, preluActivationWeights) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.conv2d = function (x, filter, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.conv2dDerInput = function (dy, filter, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.conv2dDerFilter = function (x, dY, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.depthwiseConv2D = function (input, filter, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.depthwiseConv2DDerInput = function (dy, filter, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.depthwiseConv2DDerFilter = function (x, dY, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.conv3d = function (x, filter, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.conv3dDerInput = function (dy, filter, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.conv3dDerFilter = function (x, dY, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.maxPool = function (x, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.maxPoolBackprop = function (dy, x, y, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.avgPool = function (x, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.avgPoolBackprop = function (dy, x, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.avgPool3d = function (x, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.avgPool3dBackprop = function (dy, x, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.maxPool3d = function (x, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.maxPool3dBackprop = function (dy, x, y, convInfo) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.reshape = function (x, shape) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.cast = function (x, dtype) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.tile = function (x, reps) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.pad = function (x, paddings, constantValue) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.transpose = function (x, perm) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.gather = function (x, indices, axis) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.gatherND = function (x, indices) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.scatterND = function (indices, updates, shape) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.batchToSpaceND = function (x, blockShape, crops) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.spaceToBatchND = function (x, blockShape, paddings) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.resizeBilinearBackprop = function (dy, x, alignCorners) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.resizeNearestNeighbor = function (x, newHEight, newWidth, alignCorners) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.resizeNearestNeighborBackprop = function (dy, x, alignCorners) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.LRNGrad = function (dy, inputImage, outputImage, radius, bias, alpha, beta) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.multinomial = function (logits, normalized, numSamples, seed) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.oneHot = function (indices, depth, onValue, offValue) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.cumsum = function (x, axis, exclusive, reverse) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.nonMaxSuppression = function (boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.fft = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.ifft = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.complex = function (real, imag) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.real = function (input) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.imag = function (input) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.cropAndResize = function (image, boxes, boxIndex, cropSize, method, extrapolationValue) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.depthToSpace = function (x, blockSize, dataFormat) {\n        throw new Error('Not yet implemented');\n    };\n    // Aligns with the \"SplitV\" kernel in TensorFlow.\n    KernelBackend.prototype.split = function (value, sizeSplits, axis) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.sparseToDense = function (sparseIndices, sparseValues, outputShape, defaultValue) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.diag = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.fill = function (shape, value, dtype) {\n        throw new Error('Not yet implemented.');\n    };\n    KernelBackend.prototype.onesLike = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.zerosLike = function (x) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.linspace = function (start, stop, num) {\n        throw new Error('Not yet implemented');\n    };\n    KernelBackend.prototype.dispose = function () {\n        throw new Error('Not yet implemented');\n    };\n    return KernelBackend;\n}());\nexports.KernelBackend = KernelBackend;\n"},"sourceMaps":{"js":{"version":3,"file":"backend.js","sourceRoot":"","sources":["../../src/backends/backend.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Conv2DInfo, Conv3DInfo} from '../ops/conv_util';\nimport {Activation, FusedBatchMatMulConfig} from '../ops/fused_util';\nimport {Backend, DataId, Scalar, Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D, Tensor5D} from '../tensor';\nimport {BackendValues, DataType, PixelData, Rank, ShapeMap} from '../types';\n\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n\n// Required information for all backends.\nexport interface BackendTimingInfo {\n  kernelMs: number;\n  getExtraProfileInfo?(): string;  // a field for additional timing information\n                                   // e.g. packing / unpacking for WebGL backend\n}\n\nexport interface TensorStorage {\n  read(dataId: DataId): Promise<BackendValues>;\n  readSync(dataId: DataId): BackendValues;\n  disposeData(dataId: DataId): void;\n  write(dataId: DataId, values: BackendValues): void;\n  fromPixels(\n      pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n      HTMLVideoElement,\n      numChannels: number): Tensor3D;\n  register(dataId: DataId, shape: number[], dtype: DataType): void;\n  memory(): {unreliable: boolean;};  // Backend-specific information.\n}\n\n/** Convenient class for storing tensor-related data. */\nexport class DataStorage<T> {\n  private data = new WeakMap<DataId, T>();\n\n  constructor(private backend: KernelBackend, private dataMover: DataMover) {}\n\n  get(dataId: DataId) {\n    if (!this.data.has(dataId)) {\n      this.dataMover.moveData(this.backend, dataId);\n    }\n    return this.data.get(dataId);\n  }\n\n  set(dataId: DataId, value: T): void {\n    this.data.set(dataId, value);\n  }\n\n  has(dataId: DataId): boolean {\n    return this.data.has(dataId);\n  }\n\n  delete(dataId: DataId): boolean {\n    return this.data.delete(dataId);\n  }\n}\n\nexport interface DataMover {\n  /**\n   * To be called by backends whenever they see a dataId that they don't own.\n   * Upon calling this method, the mover will fetch the tensor from another\n   * backend and register it with the current active backend.\n   */\n  moveData(backend: KernelBackend, dataId: DataId): void;\n}\n\nexport interface BackendTimer {\n  time(f: () => void): Promise<BackendTimingInfo>;\n}\n\n/**\n * The interface that defines the kernels that should be implemented when\n * adding a new backend. New backends don't need to implement every one of the\n * methods, this can be done gradually (throw an error for unimplemented\n * methods).\n */\nexport class KernelBackend implements TensorStorage, Backend, BackendTimer {\n  time(f: () => void): Promise<BackendTimingInfo> {\n    throw new Error('Not yet implemented.');\n  }\n  read(dataId: object): Promise<BackendValues> {\n    throw new Error('Not yet implemented.');\n  }\n  readSync(dataId: object): BackendValues {\n    throw new Error('Not yet implemented.');\n  }\n  disposeData(dataId: object): void {\n    throw new Error('Not yet implemented.');\n  }\n  write(dataId: object, values: BackendValues): void {\n    throw new Error('Not yet implemented.');\n  }\n  fromPixels(\n      pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n      HTMLVideoElement,\n      numChannels: number): Tensor<Rank.R3> {\n    throw new Error('Not yet implemented.');\n  }\n  register(dataId: object, shape: number[], dtype: DataType): void {\n    throw new Error('Not yet implemented.');\n  }\n  memory(): {unreliable: boolean; reasons?: string[]} {\n    throw new Error('Not yet implemented.');\n  }\n  /** Returns the highest precision for floats in bits (e.g. 16 or 32) */\n  floatPrecision(): 16|32 {\n    throw new Error('Not yet implemented');\n  }\n  /** Returns the smallest representable number.  */\n  epsilon(): number {\n    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n  }\n\n  batchMatMul(\n      a: Tensor3D, b: Tensor3D, transposeA: boolean,\n      transposeB: boolean): Tensor3D {\n    throw new Error('Not yet implemented');\n  }\n\n  fusedBatchMatMul(\n      {a, b, transposeA, transposeB, bias, activation, preluActivationWeights}:\n          FusedBatchMatMulConfig): Tensor3D {\n    throw new Error('Not yet implemented');\n  }\n\n  slice<T extends Tensor>(x: T, begin: number[], size: number[]): T {\n    throw new Error('Not yet implemented');\n  }\n  stridedSlice<T extends Tensor>(\n      x: T, begin: number[], end: number[], strides: number[]): T {\n    throw new Error('Not yet implemented');\n  }\n  unstack(x: Tensor, axis: number): Tensor[] {\n    throw new Error('Not yet implemented');\n  }\n  reverse<T extends Tensor>(a: T, axis: number[]): T {\n    throw new Error('Not yet implemented');\n  }\n\n  concat(tensors: Tensor[], axis: number): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  neg<T extends Tensor>(a: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  add(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  addN<T extends Tensor>(tensors: T[]): T {\n    throw new Error('Not yet implemented');\n  }\n  subtract(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  multiply(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  realDivide(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  floorDiv(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  sum(x: Tensor, axes: number[]): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  prod(x: Tensor, axes: number[]): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  unsortedSegmentSum<T extends Tensor>(\n      x: T, segmentIds: Tensor1D, numSegments: number): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  argMin(x: Tensor, axis: number): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  argMax(x: Tensor, axis: number): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  equal(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  notEqual(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  less(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  lessEqual(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  greater(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  greaterEqual(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  logicalNot<T extends Tensor>(a: T): T {\n    throw new Error('Not yet implemented');\n  }\n  logicalAnd(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  logicalOr(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  where(condition: Tensor): Tensor2D {\n    throw new Error('Not yet implemented');\n  }\n  select(condition: Tensor, a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  topk<T extends Tensor>(x: T, k: number, sorted: boolean): [T, T] {\n    throw new Error('Not yet implemented');\n  }\n\n  min(x: Tensor, axes: number[]): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  minimum(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  mod(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  max(x: Tensor, axes: number[]): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  maximum(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  all(x: Tensor, axes: number[]): Tensor {\n    throw new Error('Not yet implemented');\n  }\n  any(x: Tensor, axes: number[]): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  squaredDifference(a: Tensor, b: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  ceil<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  floor<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  round<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  sign<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  isNaN<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  isInf<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  isFinite<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  pow<T extends Tensor>(a: T, b: Tensor): T {\n    throw new Error('Not yet implemented');\n  }\n  exp<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  expm1<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  log<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  log1p<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  sqrt<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  rsqrt<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  square<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  reciprocal<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  relu<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  prelu<T extends Tensor>(x: T, a: T): T {\n    throw new Error('Not yet implemented');\n  }\n  elu<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  eluDer<T extends Tensor>(dy: T, y: T): T {\n    throw new Error('Not yet implemented');\n  }\n  selu<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  int<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  clip<T extends Tensor>(x: T, min: number, max: number): T {\n    throw new Error('Not yet implemented');\n  }\n\n  abs<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  complexAbs<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  sigmoid<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  softplus<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  sin<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  cos<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  tan<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  asin<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  acos<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  atan<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  atan2<T extends Tensor>(a: T, b: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  sinh<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  cosh<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  tanh<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  asinh<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  acosh<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n  atanh<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  erf<T extends Tensor>(x: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  step<T extends Tensor>(x: T, alpha: number): T {\n    throw new Error('Not yet implemented');\n  }\n\n  fusedConv2d(\n      x: Tensor4D, filter: Tensor4D, convInfo: Conv2DInfo, bias?: Tensor4D,\n      activation?: Activation, preluActivationWeights?: Tensor): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  conv2d(x: Tensor4D, filter: Tensor4D, convInfo: Conv2DInfo): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n  conv2dDerInput(dy: Tensor4D, filter: Tensor4D, convInfo: Conv2DInfo):\n      Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n  conv2dDerFilter(x: Tensor4D, dY: Tensor4D, convInfo: Conv2DInfo): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  depthwiseConv2D(input: Tensor4D, filter: Tensor4D, convInfo: Conv2DInfo):\n      Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n  depthwiseConv2DDerInput(dy: Tensor4D, filter: Tensor4D, convInfo: Conv2DInfo):\n      Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n  depthwiseConv2DDerFilter(x: Tensor4D, dY: Tensor4D, convInfo: Conv2DInfo):\n      Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n  conv3d(x: Tensor5D, filter: Tensor5D, convInfo: Conv3DInfo): Tensor5D {\n    throw new Error('Not yet implemented');\n  }\n  conv3dDerInput(dy: Tensor5D, filter: Tensor5D, convInfo: Conv3DInfo):\n      Tensor5D {\n    throw new Error('Not yet implemented');\n  }\n  conv3dDerFilter(x: Tensor5D, dY: Tensor5D, convInfo: Conv3DInfo): Tensor5D {\n    throw new Error('Not yet implemented');\n  }\n  maxPool(x: Tensor4D, convInfo: Conv2DInfo): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n  maxPoolBackprop(dy: Tensor4D, x: Tensor4D, y: Tensor4D, convInfo: Conv2DInfo):\n      Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n  avgPool(x: Tensor4D, convInfo: Conv2DInfo): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n  avgPoolBackprop(dy: Tensor4D, x: Tensor4D, convInfo: Conv2DInfo): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n  avgPool3d(x: Tensor5D, convInfo: Conv3DInfo): Tensor5D {\n    throw new Error('Not yet implemented');\n  }\n  avgPool3dBackprop(dy: Tensor5D, x: Tensor5D, convInfo: Conv3DInfo): Tensor5D {\n    throw new Error('Not yet implemented');\n  }\n  maxPool3d(x: Tensor5D, convInfo: Conv3DInfo): Tensor5D {\n    throw new Error('Not yet implemented');\n  }\n  maxPool3dBackprop(\n      dy: Tensor5D, x: Tensor5D, y: Tensor5D, convInfo: Conv3DInfo): Tensor5D {\n    throw new Error('Not yet implemented');\n  }\n\n  reshape<T extends Tensor, R extends Rank>(x: T, shape: ShapeMap[R]):\n      Tensor<R> {\n    throw new Error('Not yet implemented');\n  }\n  cast<T extends Tensor>(x: T, dtype: DataType): T {\n    throw new Error('Not yet implemented');\n  }\n\n  tile<T extends Tensor>(x: T, reps: number[]): T {\n    throw new Error('Not yet implemented');\n  }\n\n  pad<T extends Tensor>(\n      x: T, paddings: Array<[number, number]>, constantValue: number): T {\n    throw new Error('Not yet implemented');\n  }\n\n  transpose<T extends Tensor>(x: T, perm: number[]): T {\n    throw new Error('Not yet implemented');\n  }\n\n  gather<T extends Tensor>(x: T, indices: Tensor1D, axis: number): T {\n    throw new Error('Not yet implemented');\n  }\n\n  gatherND(x: Tensor, indices: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  scatterND<R extends Rank>(\n      indices: Tensor, updates: Tensor, shape: ShapeMap[R]): Tensor<R> {\n    throw new Error('Not yet implemented');\n  }\n\n  batchToSpaceND<T extends Tensor>(\n      x: T, blockShape: number[], crops: number[][]): T {\n    throw new Error('Not yet implemented');\n  }\n\n  spaceToBatchND<T extends Tensor>(\n      x: T, blockShape: number[], paddings: number[][]): T {\n    throw new Error('Not yet implemented');\n  }\n\n  resizeBilinear(\n      x: Tensor4D, newHeight: number, newWidth: number,\n      alignCorners: boolean): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  resizeBilinearBackprop(dy: Tensor4D, x: Tensor4D, alignCorners: boolean):\n      Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  resizeNearestNeighbor(\n      x: Tensor4D, newHEight: number, newWidth: number,\n      alignCorners: boolean): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  resizeNearestNeighborBackprop(\n      dy: Tensor4D, x: Tensor4D, alignCorners: boolean): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  batchNormalization(\n      x: Tensor4D, mean: Tensor4D|Tensor1D, variance: Tensor4D|Tensor1D,\n      varianceEpsilon: number, scale?: Tensor4D|Tensor1D,\n      offset?: Tensor4D|Tensor1D): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  localResponseNormalization4D(\n      x: Tensor4D, radius: number, bias: number, alpha: number,\n      beta: number): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  LRNGrad(\n      dy: Tensor4D, inputImage: Tensor4D, outputImage: Tensor4D, radius: number,\n      bias: number, alpha: number, beta: number): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  multinomial(\n      logits: Tensor2D, normalized: boolean, numSamples: number,\n      seed: number): Tensor2D {\n    throw new Error('Not yet implemented');\n  }\n\n  oneHot(indices: Tensor1D, depth: number, onValue: number, offValue: number):\n      Tensor2D {\n    throw new Error('Not yet implemented');\n  }\n\n  cumsum(x: Tensor, axis: number, exclusive: boolean, reverse: boolean):\n      Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  nonMaxSuppression(\n      boxes: Tensor2D, scores: Tensor1D, maxOutputSize: number,\n      iouThreshold: number, scoreThreshold?: number): Tensor1D {\n    throw new Error('Not yet implemented');\n  }\n\n  fft(x: Tensor2D): Tensor2D {\n    throw new Error('Not yet implemented');\n  }\n  ifft(x: Tensor2D): Tensor2D {\n    throw new Error('Not yet implemented');\n  }\n  complex<T extends Tensor>(real: T, imag: T): T {\n    throw new Error('Not yet implemented');\n  }\n  real<T extends Tensor>(input: T): T {\n    throw new Error('Not yet implemented');\n  }\n  imag<T extends Tensor>(input: T): T {\n    throw new Error('Not yet implemented');\n  }\n\n  cropAndResize(\n      image: Tensor4D, boxes: Tensor2D, boxIndex: Tensor1D,\n      cropSize: [number, number], method: 'bilinear'|'nearest',\n      extrapolationValue: number): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  depthToSpace(x: Tensor4D, blockSize: number, dataFormat: string): Tensor4D {\n    throw new Error('Not yet implemented');\n  }\n\n  // Aligns with the \"SplitV\" kernel in TensorFlow.\n  split<T extends Tensor>(value: T, sizeSplits: number[], axis: number): T[] {\n    throw new Error('Not yet implemented');\n  }\n\n  sparseToDense<R extends Rank>(\n      sparseIndices: Tensor, sparseValues: Tensor, outputShape: ShapeMap[R],\n      defaultValue: Scalar): Tensor<R> {\n    throw new Error('Not yet implemented');\n  }\n\n  diag(x: Tensor): Tensor {\n    throw new Error('Not yet implemented');\n  }\n\n  fill<R extends Rank>(\n      shape: ShapeMap[R], value: number|string, dtype?: DataType): Tensor<R> {\n    throw new Error('Not yet implemented.');\n  }\n\n  onesLike<R extends Rank>(x: Tensor<R>): Tensor<R> {\n    throw new Error('Not yet implemented');\n  }\n\n  zerosLike<R extends Rank>(x: Tensor<R>): Tensor<R> {\n    throw new Error('Not yet implemented');\n  }\n\n  linspace(start: number, stop: number, num: number): Tensor1D {\n    throw new Error('Not yet implemented');\n  }\n\n  dispose(): void {\n    throw new Error('Not yet implemented');\n  }\n}\n"]}},"error":null,"hash":"a5661acd2eee4f380ba5ca434a38b4aa","cacheData":{"env":{}}}